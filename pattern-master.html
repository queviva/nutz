<html>
<head><title>STOP CACHING!!!</title></head>
<body style="color:#333">

    <style>
        #hack {
            transition: all linear 300ms;
        }
        #hack:hover {
            transform: scale(3);
            fill: url(#hoverStarspat);
        }
    </style>
  <svg width="600" height="300" viewBox="0 0 200 100"
   style="
    background-image:url(building0.png);
    --nig-color:hsl(40,50%,50%);
   "
  >
    <defs>
      <pattern id="hoverStars" fill="pat(stars, orange)"/>
      <pattern id="hump3"></pattern>
      <pattern id="hump5"></pattern>
    </defs>

    <path id="patternPath" d="M0 0H100V100Z" 
     fill="pat(xstix, 5, var(--nig-color))"
    />
    <path id="hack" d="M0 0V100H100Z" 
     fill="pat(xdots, 1, var(--nig-color))"
    />
    <path d="M100 0v100h100Z" 
     xxx-fill="img(https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSlM57vKxq4iBteIy6aFsyC42VHHF6bMuIVrQ&s)"
     fill="image(building2.png, 0.3)"
    />
    <circle fill="green"/>
  </svg>
  <div>
    you may indicate various types of fill<br>
    for a color, use any valid css color<br>
    <pre>
        fill="green"
        fill="#909"
        fill="hsl(40,100%,50%)"
        fill="var(--css-var)"
    </pre>
    you may fill with an image from its url<br>
    using either <i>img()</i> or <i>image()</i><br>
    <pre>
        fill="img(local.png)"
        fill="image(local.png)"
        fill="img(http://external.url/img.jpg)"
    </pre>
    optionally, you may scale the image<br>
    <pre>
        fill="img(picture.png, 3.5)"
    </pre>
    fill with a pattern by its name,<br>
    using either <i>pat()</i> or <i>pattern()</i>
    <pre>
        fill="pat(dots)"
        fill="pattern(hatch)"
        fill="pat(stars)"
    </pre>
    give the pattern a color if you want
    <pre>
        fill="pat(dots, green)"
    </pre>
  </div>
<script type="module">

const NS=v=>document.createElementNS('http://www.w3.org/2000/svg',v);
const H=(d,f)=>`<path d="${d}" fill="${f}" fill-rule="evenodd" />`;
const MIG=(g,[id,url,scl])=>g.innerHTML+=`<pattern id=${id} width=1 height=1><image href="${url}" transform="scale(${scl||1})"/></pattern>`;
const PAT=(g,[id,typ,...opts],[scl,col='currentColor',bak]=[opts.find(a=>!isNaN(Number(a)))||1.3,...opts.filter(a=>CSS.supports('color',a))])=>g.innerHTML+=
    `<pattern id=${id} width=2 height=2 patternUnits=userSpaceOnUse
      patternTransform="rotate(45) scale(${scl})">` +
    (bak ? H("M0 0H2V2H0Z", bak) : '') +
    H(
      (/^x/i.test(typ)
        ? (typ = typ.replace(/^x/i, ''), 'M0 0H2V2H0Z')
        : '') +
      ({
        dots:'M0 1A.5 .5 0 1 1 0 1.1Z',
        cross:'M0 0V2H2V1.75H.25V0Z',
        hatch:'M0 0 V2H1V0Z',
        check:'M0 0H1V2H2V1H0Z',
        strip:'M.5 0H1.5L0 1.5V.5ZM2 .5V1.5L1.5 2H.5Z',
        stars:'M 0.15 0.15 L 0.6529 0.4071 L 1.06 0 L 0.9714 0.57 L 1.48 0.83 L 0.9174 0.9174 L 0.83 1.48 L 0.57 0.9714 L 0 1.06 L 0.4071 0.6529 Z',
        love:'M2 2H1.2A.3 .3 0 0 1 1.2 1.2A.3 .3 0 0 1 2 1.2Z',
        stix:'M0 0h.25v.5h.25v-.5h.75v.25h-.5v.25h.5v.75h-.25v-.5h-.25v.5h-.75v-.25h.5v-.25h-.5'
      }[typ] || typ), col
    ) + `</pattern>`;
 

document.querySelectorAll('svg').forEach(svg => {

  const defs = NS('defs');

  svg.querySelectorAll('[fill]').forEach((obj, i) => {

    const id = obj.id || 'nutz' + i;
    const fill = obj.getAttribute('fill');

    const patURL = (/^ima?g/.test(fill)?(MIG(defs,[id+'mig',...(fill.match(/\((.*)\)$/)[1].split(/,/))]),`url(#${id}mig)`):/^pat/.test(fill)?(PAT(defs,[id+'pat',...(fill.match(/\((.*)\)$/)[1].split(/,(?![^(]*\))/))]),`url(#${id}pat)`):fill);
    obj.localName === 'pattern' ?
        obj.remove() :
        obj.setAttribute('fill', patURL);

  });

  svg.append(defs);

});

</script>
</body>
</html>